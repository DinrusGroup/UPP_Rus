#include "Builders.h"
#include <coff/binobj/binobj.h>

void DmcBuilder::AddFlags(Index<String>& cfg)
{

}

bool DmcBuilder::BuildPackage(const String& package, Vector<String>& linkfile, String& linkoptions, const Vector<String>& all_uses, const Vector<String>& all_libraries, int opt)
{
	String packagepath = PackagePath(package);
	Package pkg;
	pkg.Load(packagepath);
	String packagedir = GetFileFolder(packagepath);
	ChDir(packagedir);
	PutVerbose("cd " + packagedir);
	IdeConsoleBeginGroup(package);
	Vector<String> obj;

	bool is_shared = HasFlag("SO");

	String cc = CmdLine(package, pkg),
		clc = CompilerName(true), clcpp = CompilerName(true);

	if (HasFlag("MT"))
	    cc << " ";

	if (HasFlag("WIN32"))
		cc << " ";

	String ccoptions = Gather(pkg.option, config.GetKeys());
	if (!ccoptions.IsEmpty())
		cc << ' ' << ccoptions;

	String cc_speed = cc;
	bool   release = false;

	if (HasFlag("DEBUG"))
		cc << " -D" << debug_options;
	else {
		release = true;
		cc << ' ' << release_size_options;
		cc_speed << ' ' << release_options;
		if (opt == R_SPEED || pkg.optimize_speed)
			cc = cc_speed;
	}

	Vector<String> sfile, isfile;
	Vector<String> soptions, isoptions;
	Vector<bool>   optimize, ioptimize;
	bool           error = false;

	for (int i = 0; i < pkg.GetCount(); i++) {
		if (!IdeIsBuilding())
			return false;
		if (!pkg[i].separator) {
			String gop = Gather(pkg[i].option, config.GetKeys());
			Vector<String> srcfile = CustomStep(SourcePath(package, pkg[i]));
			if (srcfile.GetCount() == 0)
				error = true;
			for (int j = 0; j < srcfile.GetCount(); j++) {
				String fn = srcfile[j];
				String ext = ToLower(GetFileExt(fn));
				if (ext == ".c" || ext == ".cpp" || ext == ".cc" || ext == ".cxx" || ext == ".rc" || ext == ".brc") {
					sfile.Add(fn);
					soptions.Add(gop);
					optimize.Add(release && pkg[i].optimize_speed && opt == R_OPTIMAL);
				}
				else
				if (ext == ".icpp") {
					isfile.Add(fn);
					isoptions.Add(gop);
					ioptimize.Add(release && pkg[i].optimize_speed && opt == R_OPTIMAL);
				}
				else
				if (ext == ".obj")
					obj.Add(fn);
				else
				if (ext == ".lib")
					linkfile.Add(fn);
			}
		}
	}

	if (HasFlag("BLITZ")) {
		Blitz b = BlitzStep(sfile, soptions, obj, ".obj", optimize);
		if (b.build) {
			PutConsole("БЛИЦ:" + b.info);
			int slot = AllocSlot();
			if (slot < 0 || !Run(String().Cat() << clcpp << cc << ' '
			<< GetHostPathQ(b.path) << " -fo=" << GetHostPathQ(b.object), slot, GetHostPath(b.object), b.count))
				error = true;
		}
	}

	int first_ifile = sfile.GetCount();
	sfile.AppendPick(isfile);
	soptions.AppendPick(isoptions);
	optimize.AppendPick(ioptimize);

	int ccount = 0;

	for (int i = 0; i < sfile.GetCount(); ++i) {
		if (!IdeIsBuilding())
			return false;
		String fn = sfile[i];
		String ext = ToLower(GetFileExt(fn));
		bool rc = (ext == ".rc");
		bool brc = (ext == ".brc");
		bool init = (i >= first_ifile);
		String objfile = CatAnyPath(outdir, GetFileName(fn) + ".obj");
		if (HdependFileTime(fn) > GetFileTime(objfile)) {
			int time = GetTickCount();
			bool execerr = false;
			if (rc) {
				PutConsole(GetFileNamePos(fn));
				objfile = ForceExt(objfile, ".res");
				int slot = AllocSlot();
				if (slot < 0 || !Run("rcc -r -x -o" + GetHostPathQ(objfile) + Includes(" -i=", package, pkg)
					+ ' ' + GetHostPathQ(fn), slot, GetHostPath(objfile), 1))
					execerr = true;
			}
		/*	else
			if (brc) {
				PutConsole(GetFileNamePos(fn));
				try {
					String hfn = GetHostPath(fn);
					String brcdata = LoadFile(hfn);
					if(brcdata.IsVoid())
						throw Exc(NFormat("ошибка при чтении файла '%s'", hfn));
					CParser parser(brcdata, hfn);
					BinaryToObject(GetHostPath(objfile), parser, GetFileDirectory(hfn), THISBACK(BinObjConsole));
				}
				catch (Exc e) {
					PutConsole(e);
					execerr = true;
				}
			}*/
			else {
				String c = cc;
				if (optimize[i])
					c = cc_speed;
				int slot = AllocSlot();

				if (slot < 0 || !Run((ext == ".c" ? clc : clcpp + " -x -r") + c + soptions[i] + ' '
					+ GetHostPathQ(fn) + " -o" + GetHostPathQ(objfile), slot, GetHostPath(objfile), 1))
					execerr = true;
			}

			if (execerr)
				DeleteFile(objfile);
			error |= execerr;
			PutVerbose("скомпилировано за " + GetPrintTime(time));
			ccount++;
		}
		if (init)
			linkfile.Add(objfile);
		else
			obj.Add(objfile);
	}

	if (error) {
		IdeConsoleEndGroup();
		return false;
	}

	Vector<String> libs = Split(Gather(pkg.library, config.GetKeys()), ' ');
	for (int i = 0, n = libs.GetCount(); i < n; ++i)
		linkfile.Add(AppendExt(libs[i], ".lib"));

	linkoptions << Gather(pkg.link, config.GetKeys());

	int linktime = GetTickCount();
	if (!HasFlag("MAIN")) {
		if (HasFlag("BLITZ") || HasFlag("NOLIB")) {
			obj.Append(linkfile);
			linkfile = obj;
			IdeConsoleEndGroup();
			return true;
		}

		String product;
		if (is_shared)
			product = GetSharedLibPath(package);
		else
			product = CatAnyPath(outdir, GetAnyFileName(package) + ".lib");

		Time producttime = GetFileTime(product);
		linkfile.Add(ForceExt(product, ".lib"));

		Vector<String> files, res;
		for (int i = 0, n = obj.GetCount(); i < n; ++i)
			if (obj[i].EndsWith("j")) // ".obj"
				files.Add(obj[i]);
			else // ".res"
				res.Add(obj[i]);

		if (!is_shared && !res.IsEmpty())
			linkfile.Append(res);

		if (!Wait()) {
			IdeConsoleEndGroup();
			return false;
		}

for (int i = 0, n = obj.GetCount(); i < n; ++i)
			if (GetFileTime(obj[i]) > producttime) {
				String lib;

				if (is_shared) {
					lib << LinkerName() << " опция спокойно(quiet)";

					if (HasFlag("DEBUG"))
					    lib << "отладка всех опция инкрементально";

					if (HasFlag("WIN32"))
						lib << " система nt_dll";

					if (!linkoptions.IsEmpty())
						lib << ' ' << linkoptions;

					if (!libpath.IsEmpty())
						lib << " путь к библиотеке \"" << Join(libpath, "\";\"") << '\"';

					if (!files.IsEmpty())
						lib << " файл '" << Join(files, "', '") << '\'';

					if (!res.IsEmpty())
						lib << " ресурс '" << Join(res, "', '") << '\'';

					const int all_usesCount = all_uses.GetCount(),
						all_librariesCount = all_libraries.GetCount();

					if (all_usesCount > 0 || all_librariesCount > 0) {
						lib << " библиотека ";

						for (int j = 0, k = all_usesCount - 1; j < all_usesCount; ++j) {
							lib << '\'' << GetHostPath(ForceExt(GetSharedLibPath(all_uses[j]), ".lib")) << '\'';

							if (j < k)
								lib << ", ";
						}

						if (all_usesCount > 0 && all_librariesCount > 0)
							lib << ", ";

						for (int j = 0, k = all_librariesCount - 1; j < all_librariesCount; ++j) {
							lib << '\'' << AppendExt(all_libraries[j], ".lib") << '\'';

							if (j < k)
								lib << ", ";
						}
					}

					lib << " имя '" << product << '\'';
				}
				else {
					lib << "wlib -q -b -n ";

					if (!linkoptions.IsEmpty())
						lib << linkoptions;

					lib << '\'' << product << '\'';

					for (int j = 0, m = files.GetCount(); j < m; ++j)
						lib << " '" << GetHostPath(files[j]) << '\'';
				}

				PutConsole("Создаётся библиотека...");
				IdeConsoleEndGroup();
				DeleteFile(product);

				if (Execute(lib)) {
					DeleteFile(product);
					return false;
				}

				PutConsole(String().Cat() << product << " (" << GetFileInfo(product).length
				           << " B) создана за " << GetPrintTime(linktime));

				break;
			}

		return true;
	}

	obj.Append(linkfile);
	linkfile = obj;
	return true;
}

bool DmcBuilder::Link(const Vector<String>& linkfile, const String& linkoptions, bool createmap)
{
	int time = GetTickCount();
	if (!Wait())
		return false;

	const int linkfileCount = linkfile.GetCount();

	for (int i = 0; i < linkfileCount; i++)
		if (GetFileTime(linkfile[i]) >= targettime) {
			String link;
			link << LinkerName() << " option quiet";

			if (HasFlag("DEBUG"))
			    link << " отладка всех опция инкрементально";

			if (HasFlag("WIN32"))
				if (HasFlag("GUI"))
					link << " система nt_win";
				else if (HasFlag("DLL"))
					link << " система nt_dll";
				else link << " система nt";

			if (createmap)
				link << " карта опций";

			if (!linkoptions.IsEmpty())
				link << ' ' << linkoptions;

			if (!libpath.IsEmpty())
				link << " путь к библиотеке \"" << Join(libpath, "\";\"") << '\"';

			Vector<String> files, libs, res;

			for (int j = 0; j < linkfileCount; ++j) {
				const String ext(linkfile[j].Right(1));
				if (ext == "j") // ".obj"
					files.Add(linkfile[j]);
				else if (ext == "b") // ".lib"
					libs.Add(linkfile[j]);
				else // ".res"
					res.Add(linkfile[j]);
			}

			if (!files.IsEmpty())
				link << " файл '" << Join(files, "', '") << '\'';

			if (!res.IsEmpty())
				link << " ресурс '" << Join(res, "', '") << '\'';

			if (!libs.IsEmpty())
				link << " библиотека '" << Join(libs, "', '") << '\'';

			link << " имя '" << GetHostPath(target) << '\'';

			PutConsole("Компоновка...");
			CustomStep(".pre-link");
			if (Execute(link) == 0) {
				CustomStep(".post-link");

				PutConsole(String().Cat() << GetHostPath(target) << " (" << GetFileInfo(target).length
				           << " B) скомпоновано за " << GetPrintTime(time));
				return true;
			}
			else {
				DeleteFile(target);
				return false;
			}
		}

	PutConsole(String().Cat() << GetHostPath(target) << " (" << GetFileInfo(target).length
	           << " B) в свежем состоянии.");
	return true;
}

bool DmcBuilder::Preprocess(const String& package, const String& file, const String& target, bool asmout)
{
	FileOut out(target);
	const String packagepath = PackagePath(package);
	Package pkg;
	pkg.Load(packagepath);

	return Execute((GetFileExt(file) == ".c" ? CompilerName(false) : CompilerName(true)) + CmdLine(package, pkg) + " -pl " + file, out);
}

String DmcBuilder::IncludesDefinesTargetTime(const String& package, const Package& pkg)
{
	String cc = Includes(" -I", package, pkg);

	for (int i = 0; i < config.GetCount(); i++)
		cc << " -Dflag" << config[i];

	Time t = GetSysTime();
	cc << " -DbmYEAR=" << (int)t.year;
	cc << " -DbmMONTH=" << (int)t.month;
	cc << " -DbmDAY=" << (int)t.day;
	cc << " -DbmHOUR=" << (int)t.hour;
	cc << " -DbmMINUTE=" << (int)t.minute;
	cc << " -DbmSECOND=" << (int)t.second;
	targettime = GetFileTime(target);

	return cc;
}

String DmcBuilder::CompilerName(bool isCpp) const
{
	if (!IsNull(compiler)) return compiler;
	return "dmc"; // C++ or C compiler
}

String DmcBuilder::LinkerName() const
{
	return "dmlink";//"dmlink"
}

String DmcBuilder::CmdLine(const String& package, const Package& pkg)
{
	return String().Cat() << " -c -L -mn -Ab -Ae -DPLATFORM_WIN32 -D__DMC__ -D__UPP__ -cpp" << IncludesDefinesTargetTime(package, pkg);
	// "-fr=" - do not create error files
}

Builder *CreateDmcBuilder()
{
	return new DmcBuilder;
}

INITBLOCK
{
	RegisterBuilder("DMC", CreateDmcBuilder);
}
